[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "title",
    "section": "",
    "text": "Here you find this and that.\n\n\nThese are (probably) all the libraries you will need\n\nlibrary(adehabitatHS)\n\nLoading required package: sp\n\n\nLoading required package: ade4\n\n\nLoading required package: adehabitatMA\n\n\nRegistered S3 methods overwritten by 'adehabitatMA':\n  method                       from\n  print.SpatialPixelsDataFrame sp  \n  print.SpatialPixels          sp  \n\n\nLoading required package: adehabitatHR\n\n\nLoading required package: deldir\n\n\ndeldir 1.0-6      Nickname: \"Mendacious Cosmonaut\"\n\n\n\n     The syntax of deldir() has had an important change. \n     The arguments have been re-ordered (the first three \n     are now \"x, y, z\") and some arguments have been \n     eliminated.  The handling of the z (\"tags\") \n     argument has been improved.\n \n     The \"dummy points\" facility has been removed. \n     This facility was a historical artefact, was really \n     of no use to anyone, and had hung around much too \n     long.  Since there are no longer any \"dummy points\", \n     the structure of the value returned by deldir() has \n     changed slightly.  The arguments of plot.deldir() \n     have been adjusted accordingly; e.g. the character \n     string \"wpoints\" (\"which points\") has been \n     replaced by the logical scalar \"showpoints\". \n     The user should consult the help files.\n\n\nLoading required package: adehabitatLT\n\n\nLoading required package: CircStats\n\n\nLoading required package: MASS\n\n\nLoading required package: boot\n\nlibrary(data.table)\nlibrary(cowplot)\nlibrary(drc)\n\n\n'drc' has been loaded.\n\n\nPlease cite R and 'drc' if used for a publication,\n\n\nfor references type 'citation()' and 'citation('drc')'.\n\n\n\nAttaching package: 'drc'\n\n\nThe following objects are masked from 'package:stats':\n\n    gaussian, getInitial\n\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following object is masked from 'package:cowplot':\n\n    stamp\n\n\nThe following objects are masked from 'package:data.table':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(MASS)\nlibrary(pdftools)\n\nUsing poppler version 22.04.0\n\nlibrary(png)\nlibrary(raster)\n\n\nAttaching package: 'raster'\n\n\nThe following object is masked from 'package:MASS':\n\n    select\n\nlibrary(rgdal)\n\nPlease note that rgdal will be retired by the end of 2023,\nplan transition to sf/stars/terra functions using GDAL and PROJ\nat your earliest convenience.\n\nrgdal: version: 1.5-32, (SVN revision 1176)\nGeospatial Data Abstraction Library extensions to R successfully loaded\nLoaded GDAL runtime: GDAL 3.4.3, released 2022/04/22\nPath to GDAL shared files: C:/Users/iei031/AppData/Local/R/win-library/4.2/rgdal/gdal\nGDAL binary built with GEOS: TRUE \nLoaded PROJ runtime: Rel. 7.2.1, January 1st, 2021, [PJ_VERSION: 721]\nPath to PROJ shared files: C:/Users/iei031/AppData/Local/R/win-library/4.2/rgdal/proj\nPROJ CDN enabled: FALSE\nLinking to sp version:1.5-0\nTo mute warnings of possible GDAL/OSR exportToProj4() degradation,\nuse options(\"rgdal_show_exportToProj4_warnings\"=\"none\") before loading sp or rgdal.\n\nlibrary(rgeos)\n\nrgeos version: 0.5-9, (SVN revision 684)\n GEOS runtime version: 3.9.1-CAPI-1.14.2 \n Please note that rgeos will be retired by the end of 2023,\nplan transition to sf functions using GEOS at your earliest convenience.\n GEOS using OverlayNG\n Linking to sp version: 1.5-0 \n Polygon checking: TRUE \n\nlibrary(rminer)\nlibrary(sf)\n\nLinking to GEOS 3.9.1, GDAL 3.4.3, PROJ 7.2.1; sf_use_s2() is TRUE\n\nlibrary(snow)\nlibrary(splitstackshape)\nlibrary(terra)\n\nterra 1.6.17\n\n\n\nAttaching package: 'terra'\n\n\nThe following object is masked from 'package:rgdal':\n\n    project\n\n\nThe following object is masked from 'package:data.table':\n\n    shift\n\n\nThe following object is masked from 'package:MASS':\n\n    area\n\n\nThe following object is masked from 'package:adehabitatMA':\n\n    buffer\n\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ lubridate::as.difftime() masks base::as.difftime()\n✖ dplyr::between()         masks data.table::between()\n✖ lubridate::date()        masks base::date()\n✖ tidyr::extract()         masks terra::extract(), raster::extract()\n✖ dplyr::filter()          masks stats::filter()\n✖ dplyr::first()           masks data.table::first()\n✖ lubridate::hour()        masks data.table::hour()\n✖ dplyr::id()              masks adehabitatLT::id()\n✖ terra::intersect()       masks rgeos::intersect(), raster::intersect(), lubridate::intersect(), base::intersect()\n✖ lubridate::isoweek()     masks data.table::isoweek()\n✖ dplyr::lag()             masks stats::lag()\n✖ dplyr::last()            masks data.table::last()\n✖ lubridate::mday()        masks data.table::mday()\n✖ lubridate::minute()      masks data.table::minute()\n✖ lubridate::month()       masks data.table::month()\n✖ lubridate::quarter()     masks data.table::quarter()\n✖ lubridate::second()      masks data.table::second()\n✖ dplyr::select()          masks raster::select(), MASS::select()\n✖ rgeos::setdiff()         masks lubridate::setdiff(), base::setdiff()\n✖ lubridate::stamp()       masks cowplot::stamp()\n✖ purrr::transpose()       masks data.table::transpose()\n✖ terra::union()           masks rgeos::union(), raster::union(), lubridate::union(), base::union()\n✖ lubridate::wday()        masks data.table::wday()\n✖ lubridate::week()        masks data.table::week()\n✖ lubridate::yday()        masks data.table::yday()\n✖ lubridate::year()        masks data.table::year()\n\nlibrary(tmap)"
  },
  {
    "objectID": "disturbance_prediction.html",
    "href": "disturbance_prediction.html",
    "title": "1  Disturbance prediction",
    "section": "",
    "text": "using the disturbance assessments from the field"
  },
  {
    "objectID": "disturbance_prediction.html#load-files-and-clean",
    "href": "disturbance_prediction.html#load-files-and-clean",
    "title": "1  Disturbance prediction",
    "section": "1.1 Load files and clean",
    "text": "1.1 Load files and clean\n\n# Load the disturbance field data\nplots<- read.csv(\"datafiles/goose_grubbing_small_veg_goose.csv\", sep=\";\")\n\n# Load the spatial file for field plots\nplot_sf<-read_sf(\"datafiles/grubbing_small_plot.shp\")\n\n# Calculate the centroid of the plots\nplot_sf$centroid <- st_centroid(plot_sf$geometry)\n\n# Extract central coordinates of small plots\nplot_sf <- plot_sf  %>% \n  mutate(x = map_dbl(geometry, ~st_centroid(.x)[[1]]),\n         y = map_dbl(geometry, ~st_centroid(.x)[[2]]))\n\n# Create dataframe with xy coordinates as columns\ncoordinates <- plot_sf %>% st_drop_geometry() %>% dplyr::select(sub_plot=Name,x,y)\n\n# Clean the dataset, group classes and add presence absence columns\ndf <-dplyr::select(plots, sub_plot, group_of_plots, date_snow_free, veg =field_class_vier, bull_pa, pick_pa, date_disturbance) %>% \n  filter(!(veg == 'na')) %>%\n  filter(!(date_snow_free == 'late')) %>%\n  mutate(disturbance = ifelse((bull_pa < 1) & (pick_pa < 1), 0, 1)) %>%\n  inner_join(coordinates) %>% \n  mutate(veg_class = recode(veg, 'wet' = 'moist'))\ndf$veg_class<-gsub('hmo', 'dry',df$veg_class)\n\ndf$pick_pa<-df$disturbance-df$bull_pa\n\n# Add new column that translates snowfree date into snow-free days\ndf$snow<-df$date_snow_free\n\ndf$snow[df$snow == \"153\"]<-2\ndf$snow[df$snow == \"150\"]<-6\ndf$snow[df$snow == \"146\"]<-10\ndf$snow[df$snow == \"142\"]<-14\ndf$snow[df$snow == \"138\"]<-18\ndf$snow[df$snow == \"134\"]<-22\n\n# Change to factor and numeric where necessary\ndf$veg_class<- as.factor(df$veg_class)\ndf$snow<- as.numeric(df$snow)"
  },
  {
    "objectID": "disturbance_prediction.html#modelling-disturbance-probability",
    "href": "disturbance_prediction.html#modelling-disturbance-probability",
    "title": "1  Disturbance prediction",
    "section": "1.2 Modelling disturbance probability",
    "text": "1.2 Modelling disturbance probability\n\n# Select data for disturbance model (snow-free date)\nd <- dplyr::select(df, veg_class, snow=date_snow_free, disturbance)\nd$snow<-as.numeric(d$snow)\nd$expsnow <- exp(d$snow)\nlevels(d$veg_class) <- c(\"dwarf shrub heath\", \"moss tundra\")\n\n\n# Disturbance model with different slope for both vegetation classes\nmossheath.drm32 <- drm(disturbance ~ expsnow, veg_class, data = d,\n                       fct = LL2.3(), type = \"binomial\", pmodels = data.frame(veg_class, veg_class, veg_class))\nmossheath.drm32\nsummary(mossheath.drm32)\n\n# Predict the model to 100 points for plotting\npred.newdata<-cbind.data.frame(snow=seq(134,153,length=100),expsnow=exp(seq(134,153,length=100)),\n                               veg_class=rep(c(\"dwarf shrub heath\", \"moss tundra\"),each=100))\n\npred.newdata$pred.dm<-predict(mossheath.drm32,newdata=pred.newdata)\n\nplot(pred.dm~snow, data=pred.newdata,subset=veg_class==\"dwarf shrub heath\",\n     type=\"l\",col=\"red\", ylim=c(0,1),ylab=\"Prop grubbing\")\nlines(pred.dm~snow, data=pred.newdata,subset=veg_class==\"moss tundra\",col=\"blue\")\n# Disturbance model with same slope for both vegetation classes\npred.newdata<-cbind.data.frame(snow=seq(134,153,length=100),expsnow=exp(seq(134,153,length=100)),\n                               veg_class=rep(c(\"dwarf shrub heath\", \"moss tundra\"),each=100))\nmossheath.drm32.b <- drm(disturbance ~ expsnow, veg_class, data = d,\n                         fct = LL2.3(), type = \"binomial\", pmodels = data.frame(1, veg_class, veg_class))\nsummary(mossheath.drm32.b)\npred.newdata$pred.dm.b<-predict(mossheath.drm32.b,newdata=pred.newdata)"
  },
  {
    "objectID": "disturbance_prediction.html#calculate-means-and-plot-the-predictions",
    "href": "disturbance_prediction.html#calculate-means-and-plot-the-predictions",
    "title": "1  Disturbance prediction",
    "section": "1.3 Calculate means and plot the predictions",
    "text": "1.3 Calculate means and plot the predictions\n\n# Calculate the mean disturbance per vegetation class and snowfree date\nmean_veg_snow<-group_by(d, snow, veg_class) %>%\n  summarize_at(vars(disturbance),\n               list(~length(.),\n                    ~mean(., na.rm = T)))\n# Move one point minimally so that they are both visible and don't overlap\nmean_veg_snow[7,1] = 146.2\n\n\n# Plot the disturbance model\npdf(\"Figures/grubbing_model_drc.pdf\",         # File name\n    width = 5, height = 5, # Width and height in inches\n    bg = \"white\")\n\nplot(range(mean_veg_snow[,1]), range(c(0,1)), type='n', ylab=\"Disturbance probability (0-1)\", xlab=\"Snowmelt date (Julian date)\")\nlines(pred.dm.b~snow, lwd = 2, data=pred.newdata,subset=veg_class==\"moss tundra\",col=\"#B21EB6\")\nlines(pred.dm.b~snow, lwd = 2, data=pred.newdata,subset=veg_class==\"dwarf shrub heath\",col=\"#FFC000\")\npar(new=TRUE)\nplot(mean_veg_snow$snow, mean_veg_snow$mean, axes=FALSE, ylab=\"\", xlab=\"\", col=\"black\", bg=c('#FFC000', '#B21EB6')[as.numeric(mean_veg_snow$veg_class)], pch=21)\nlegend(134, 0.15, legend=c(\"moss tundra\", \"dwarf-shrub heath\"), col=c(\"#B21EB6\", \"#FFC000\"), \n       lty=1, lwd = 2, cex=0.8, box.lty=0)\n\ndev.off()"
  },
  {
    "objectID": "disturbance_prediction.html#run-model-for-use-in-next-scripts",
    "href": "disturbance_prediction.html#run-model-for-use-in-next-scripts",
    "title": "1  Disturbance prediction",
    "section": "1.4 Run model for use in next scripts",
    "text": "1.4 Run model for use in next scripts\nRunning the same model with vegetation classes as with factor names 1 or 2 instead of class names to use in the disturbance maps (disturbance_map_satellite, disturbance_map_drone). You can avoid this step by running the model with numeric factors from the beginning and then relabel for plotting instead…\n\nd_map <- dplyr::select(df, veg_class, snow=date_snow_free, disturbance)\nd_map$snow<-as.numeric(d_map$snow)\nd_map$expsnow <- exp(d_map$snow)\nlevels(d_map$veg_class) <- c(2,1)\n\nmap.drm32 <- drm(disturbance ~ expsnow, veg_class, data = d_map,\n                         fct = LL2.3(), type = \"binomial\", pmodels = data.frame(1, veg_class, veg_class))"
  },
  {
    "objectID": "disturbance_prediction.html#libraries",
    "href": "disturbance_prediction.html#libraries",
    "title": "1  Disturbance prediction",
    "section": "1.1 Libraries",
    "text": "1.1 Libraries\nThese are (probably) all the libraries you will need\n\nlibrary(drc)\nlibrary(png)\nlibrary(sf)\nlibrary(tidyverse)"
  },
  {
    "objectID": "satellite_snowcover_map.html",
    "href": "satellite_snowcover_map.html",
    "title": "2  Satellite snow cover map",
    "section": "",
    "text": "This script loads the classified satellite raster images and merges them into one stack where each stacked layer indicates which areas became free from snow since the last date"
  },
  {
    "objectID": "satellite_snowcover_map.html#produce-a-single-rasterstack-for-new-snow-free-areas-in-each-stack",
    "href": "satellite_snowcover_map.html#produce-a-single-rasterstack-for-new-snow-free-areas-in-each-stack",
    "title": "2  Satellite snow cover map",
    "section": "2.1 Produce a single rasterstack for new snow-free areas in each stack",
    "text": "2.1 Produce a single rasterstack for new snow-free areas in each stack\nThis is script cleans the classified snow/no snow satellite rasters and stacks them into a single file I made a “manual loop” where I repeated the same chunk of code for each layer. Please don’t judge. :)\n\n# Load the classified snow - no snow satellite images, only select the layer that has the snow data (layer 6)\n\nsn0510 = rast(\"raster_input/d_20190510_fin.tif\")\nsn0510<-sn0510[[6]]\n\nsn0522 = rast(\"raster_input/d_20190522_fin.tif\")\nsn0522<-sn0522[[6]]\n\nsn0523 = rast(\"raster_input/d_20190523_fin.tif\")\nsn0523<-sn0523[[6]]\n\nsn0527 = rast(\"raster_input/d_20190527_fin.tif\")\nsn0527<-sn0527[[6]]\n\nsn0528 = rast(\"raster_input/d_20190528_fin.tif\")\nsn0528<-sn0528[[6]]\n\nsn0601 = rast(\"raster_input/d_20190601_fin.tif\")\nsn0601<-sn0601[[6]]\n\n# This is a procedure to label each raster layer with the area that is newly snow-free\n\n# Reclassify the first layer (1 snow, 5 snow-free)\nsn0510_re <- classify(sn0510, cbind(NA, 1))\nsn0510_re <- classify(sn0510_re, cbind(0, 5))\n\n\n# Rename the first layer \nsn1<-sn0510_re\n\n#reclassify new layer\nsn_re <- classify(sn0522, cbind(NA, 1))\n\n# start repeated chunk\n\n# reclassify the snow/snow free layers to make different from the one above\n# 10 for snow, 20 for snowfree\nsn_re <- classify(sn_re, cbind(0, 10))\nsn_re <- classify(sn_re, cbind(1, 20))\n\n# add the previous layer to the new one\nsn<-sn_re+sn1\n\n# reclassify the added layer, all areas that had had snow but are newly free of snow get the label 5, all other 1\nm <- c(11, 1,\n       15, 5,\n       21, 1,\n       25, 1)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn1 <- classify(sn, rclmat, include.lowest=TRUE)\n\n# --- end of chunk\n\n\n#rename the new layer to keep it\nsn0522_x<-sn1\n\n#reclassify the next new layer, and then repeat the chunk\nsn_re <- classify(sn0523, cbind(NA, 1))\n\n# start repeated chunk\n\n# reclassify the snow/snow free layers to make different from the one above\n# 10 for snow, 20 for snowfree\nsn_re <- classify(sn_re, cbind(0, 10))\nsn_re <- classify(sn_re, cbind(1, 20))\n\n# add the previous layer to the new one\nsn<-sn_re+sn1\n\n# reclassify the added layer, all areas that had had snow but are newly free of snow get the label 5, all other 1\nm <- c(11, 1,\n       15, 5,\n       21, 1,\n       25, 1)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn1 <- classify(sn, rclmat, include.lowest=TRUE)\n\n# --- end of chunk\n\n#rename\nsn0523_x<-sn1\n\n#reclassify new layer\nsn_re <- classify(sn0527, cbind(NA, 1))\n\n# start repeated chunk\n\n# reclassify the snow/snow free layers to make different from the one above\n# 10 for snow, 20 for snowfree\nsn_re <- classify(sn_re, cbind(0, 10))\nsn_re <- classify(sn_re, cbind(1, 20))\n\n# add the previous layer to the new one\nsn<-sn_re+sn1\n\n# reclassify the added layer, all areas that had had snow but are newly free of snow get the label 5, all other 1\nm <- c(11, 1,\n       15, 5,\n       21, 1,\n       25, 1)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn1 <- classify(sn, rclmat, include.lowest=TRUE)\n\n# --- end of chunk\n\n#rename\nsn0527_x<-sn1\n\n#reclassify new layer\nsn_re <- classify(sn0528, cbind(NA, 1))\n\n# start repeated chunk\n\n# reclassify the snow/snow free layers to make different from the one above\n# 10 for snow, 20 for snowfree\nsn_re <- classify(sn_re, cbind(0, 10))\nsn_re <- classify(sn_re, cbind(1, 20))\n\n# add the previous layer to the new one\nsn<-sn_re+sn1\n\n# reclassify the added layer, all areas that had had snow but are newly free of snow get the label 5, all other 1\nm <- c(11, 1,\n       15, 5,\n       21, 1,\n       25, 1)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn1 <- classify(sn, rclmat, include.lowest=TRUE)\n\n# --- end of chunk\n\n#rename\nsn0528_x<-sn1\n\n#reclassify new layer\nsn_re <- classify(sn0601, cbind(NA, 1))\n\n# start repeated chunk\n\n# reclassify the snow/snow free layers to make different from the one above\n# 10 for snow, 20 for snowfree\nsn_re <- classify(sn_re, cbind(0, 10))\nsn_re <- classify(sn_re, cbind(1, 20))\n\n# add the previous layer to the new one\nsn<-sn_re+sn1\n\n# reclassify the added layer, all areas that had had snow but are newly free of snow get the label 5, all other 1\nm <- c(11, 1,\n       15, 5,\n       21, 1,\n       25, 1)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn1 <- classify(sn, rclmat, include.lowest=TRUE)\n\n# --- end of chunk\n\n#rename\nsn0601_x<-sn1\n\n# add all the reclassified layers together into 1 raster stack\nsn6<-c(sn0510_re, sn0522_x, sn0523_x, sn0527_x, sn0528_x, sn0601_x)\n\n# load the extent of the study area\nsat_extent= read_sf(\"datafiles/goose_survey_1000.shp\")\n\n# crop the snow raster to the study extent\nsn6_crop=crop(sn6, vect(sat_extent))\nsn6_crop=mask(sn6_crop, vect(sat_extent))\n\nnames(sn6_crop)<-c('snow130', 'snow142', 'snow143', 'snow147', 'snow148', 'snow152')"
  },
  {
    "objectID": "satellite_snowcover_map.html#make-snow-cover-maps-for-dates-where-there-was-a-big-gap-in-data",
    "href": "satellite_snowcover_map.html#make-snow-cover-maps-for-dates-where-there-was-a-big-gap-in-data",
    "title": "2  Satellite snowcover map",
    "section": "2.2 Make snow-cover maps for dates where there was a big gap in data",
    "text": "2.2 Make snow-cover maps for dates where there was a big gap in data\n\n# Calculate the snow extent for the 30th of May\n\n#load rasters and reclassify (early date the vegetation is labelled 1, the late date, snow gets labelled 1)\nsn28 <- classify(sn6_crop$snow148, cbind(5, NA))\nsn01 <- classify(sn6_crop$snow152, cbind(1, NA))\nsn01 <- classify(sn01, cbind(5, 1))\n\n#calculate distance to vegetation edge for the early data and snow edge for the late date\nsn28_dist <- distance(sn28)\nsn01_dist <- distance(sn01)\n\n# Rename\nsn01x<-sn01_dist\nsn28x<-sn28_dist\n\n#Find the areas that are in the middle of the vegetation buffer of the early date and the snow buffer of the late day\n# this is to estimate the snow cover for the date between\n\nsn01x[sn01x <  sn28x] <- 500\n\nm <- c(0, 498, 0,\n       498, 501, 1)\nrclmat <- matrix(m, ncol=3, byrow=TRUE)\nsn01x <- classify(sn01x, rclmat, include.lowest=TRUE)\n\n# reclassify the late date layer \nsn01y <- classify(sn6_crop$snow152, cbind(5, 0))\n\n# multiply with the late date layer and reclassify to add the interpolated snow cover to the snow cover that is still there during the later date\nsn01xy<-sn01y*sn01x\n\nsn30<-sn6_crop$snow152+sn01xy\n\nm <- c(1, 1,\n       2, 5,\n       5, 5)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn30x <- classify(sn30, rclmat, include.lowest=TRUE)\n\n\n# Do the same kind of interpolation for the 18th of May\n\n# Reclassify the first layer (1 snow, 5 snow-free)\nsn10 <- classify(sn6_crop$snow130, cbind(5, NA))\nsn22 <- classify(sn6_crop$snow142, cbind(1, NA))\nsn22 <- classify(sn22, cbind(5, 1))\n\n#calculate distance to veg and snow edge\nsn10_dist <- distance(sn10)\nsn22_dist <- distance(sn22)\n\nsn10x<-sn10_dist\nsn22x<-sn22_dist\n\nsn22x[sn22x <  sn10x] <- 5500\n\nm <- c(0, 5020, 0,\n       5020, 5600, 1)\nrclmat <- matrix(m, ncol=3, byrow=TRUE)\nsn22x <- classify(sn22x, rclmat, include.lowest=TRUE)\n\nsn22y <- classify(sn6_crop$snow142, cbind(5, 0))\n\nsn22xy<-sn22y*sn22x\n\nsn18<-sn6_crop$snow142+sn22xy\n\nm <- c(1, 1,\n       2, 5,\n       5, 5)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn18x <- classify(sn18, rclmat, include.lowest=TRUE)"
  },
  {
    "objectID": "satellite_snowcover_map.html#stack-the-eight-rasters-into-single-stack-and-save-outputs",
    "href": "satellite_snowcover_map.html#stack-the-eight-rasters-into-single-stack-and-save-outputs",
    "title": "2  Satellite snow cover map",
    "section": "2.3 Stack the eight rasters into single stack and save outputs",
    "text": "2.3 Stack the eight rasters into single stack and save outputs\n\n# Stack the new rasters together with the other ones\nsn8<-c(sn6_crop$snow130, sn18x, sn6_crop$snow142, sn6_crop$snow143, sn6_crop$snow147, sn6_crop$snow148, sn30x, sn6_crop$snow152)\n\n# Rename the layers in the stack\nnames(sn8)<-c('snow130','snow138', 'snow142', 'snow143', 'snow147', 'snow148', 'snow150', 'snow152')\n\n# Save the raster or use further in \"sat_grubbing_map\"\nwriteRaster(sn8, \"raster_output/raster_snow_all8_layers_cleaned_clipped.tif\", overwrite=TRUE)\n\n# Make a frequenct table of snowmelt\nfreqy<-as.data.frame(freq(sn8)) \nfreqy$julian<-c(130,130, 138,138, 142,142,143,143,147,147,148,148,150,150,152,152)\nfreqy$value<-as.factor(freqy$value)\nlevels(freqy$value) <- c(\"snow-free\",\"snow\")\nwrite.table(freqy, file = \"data_output/satellite_snow_no_snow.txt\", append = FALSE, sep =  \"\\t\", dec = \".\",\n            row.names = FALSE, col.names = TRUE)\n\nplot(sn8)"
  },
  {
    "objectID": "satellite_snowcover_map.html#make-snow-cover-maps-for-dates-where-there-was-a-timegaps-in-the-data",
    "href": "satellite_snowcover_map.html#make-snow-cover-maps-for-dates-where-there-was-a-timegaps-in-the-data",
    "title": "2  Satellite snow cover map",
    "section": "2.2 Make snow cover maps for dates where there was a timegaps in the data",
    "text": "2.2 Make snow cover maps for dates where there was a timegaps in the data\n\n# Calculate the snow extent for the 30th of May\n\n#load rasters and reclassify (early date the vegetation is labelled 1, the late date, snow gets labelled 1)\nsn28 <- classify(sn6_crop$snow148, cbind(5, NA))\nsn01 <- classify(sn6_crop$snow152, cbind(1, NA))\nsn01 <- classify(sn01, cbind(5, 1))\n\n#calculate distance to vegetation edge for the early data and snow edge for the late date\nsn28_dist <- distance(sn28)\nsn01_dist <- distance(sn01)\n\n# Rename\nsn01x<-sn01_dist\nsn28x<-sn28_dist\n\n#Find the areas that are in the middle of the vegetation buffer of the early date and the snow buffer of the late day\n# this is to estimate the snow cover for the date between\n\nsn01x[sn01x <  sn28x] <- 500\n\nm <- c(0, 498, 0,\n       498, 501, 1)\nrclmat <- matrix(m, ncol=3, byrow=TRUE)\nsn01x <- classify(sn01x, rclmat, include.lowest=TRUE)\n\n# reclassify the late date layer \nsn01y <- classify(sn6_crop$snow152, cbind(5, 0))\n\n# multiply with the late date layer and reclassify to add the interpolated snow cover to the snow cover that is still there during the later date\nsn01xy<-sn01y*sn01x\n\nsn30<-sn6_crop$snow152+sn01xy\n\nm <- c(1, 1,\n       2, 5,\n       5, 5)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn30x <- classify(sn30, rclmat, include.lowest=TRUE)\n\n\n# Do the same kind of interpolation for the 18th of May\n\n# Reclassify the first layer (1 snow, 5 snow-free)\nsn10 <- classify(sn6_crop$snow130, cbind(5, NA))\nsn22 <- classify(sn6_crop$snow142, cbind(1, NA))\nsn22 <- classify(sn22, cbind(5, 1))\n\n#calculate distance to veg and snow edge\nsn10_dist <- distance(sn10)\nsn22_dist <- distance(sn22)\n\nsn10x<-sn10_dist\nsn22x<-sn22_dist\n\nsn22x[sn22x <  sn10x] <- 5500\n\nm <- c(0, 5020, 0,\n       5020, 5600, 1)\nrclmat <- matrix(m, ncol=3, byrow=TRUE)\nsn22x <- classify(sn22x, rclmat, include.lowest=TRUE)\n\nsn22y <- classify(sn6_crop$snow142, cbind(5, 0))\n\nsn22xy<-sn22y*sn22x\n\nsn18<-sn6_crop$snow142+sn22xy\n\nm <- c(1, 1,\n       2, 5,\n       5, 5)\nrclmat <- matrix(m, ncol=2, byrow=TRUE)\nsn18x <- classify(sn18, rclmat, include.lowest=TRUE)"
  }
]